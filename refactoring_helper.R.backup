# ==============================================================================
# REFACTORING HELPER SCRIPT
# Purpose: Systematic refactoring of function and variable names to snake_case
# Date: 2025-11-04
# ==============================================================================

# FUNCTION NAME MAPPINGS -------------------------------------------------------
# Maps old camelCase names to new snake_case names

function_mappings <- c(
  # rim_post_dump_functions.R
  "coherenceEstratoRimGear" = "coherence_estrato_rim_gear",
  "numberOfShips" = "number_of_ships",
  "numberOfRejections" = "number_of_rejections",
  "sopGreaterPesMueVivo" = "sop_greater_pes_mue_vivo",
  "sopZero" = "sop_zero",
  "pesMueDesemZero" = "pes_mue_desem_zero",
  "pesMueDesemGreaterPesDesem" = "pes_mue_desem_greater_pes_desem",
  "sopGreaterPesVivo" = "sop_greater_pes_vivo",
  "speciesWithCategoriesWithSameWeightLanding" = "species_with_categories_with_same_weight_landing",
  "allCategoriesWithSameSampledWeights" = "all_categories_with_same_sampled_weights",
  "doubtfulCategorySpecies" = "doubtful_category_species",
  "notAllowedCategorySpecies" = "not_allowed_category_species",
  "shipsNotRegistered" = "ships_not_registered",
  "shipsNotInCFPO" = "ships_not_in_cfpo",
  "checkMt2bRimStratum" = "check_mt2b_rim_stratum",
  "weightSampledZeroWithLengthsSampled" = "weight_sampled_zero_with_lengths_sampled",
  "weightLandedZero" = "weight_landed_zero",
  "weightSampledWithoutLengthsSampled" = "weight_sampled_without_lengths_sampled",
  "mixedSpeciesInCategory" = "mixed_species_in_category",
  "doubtfulSampledSpecies" = "doubtful_sampled_species",
  "notAllowedSampledSpecies" = "not_allowed_sampled_species",
  "sexesWithSameSampledWeight" = "sexes_with_same_sampled_weight",
  "categoriesWithRepeatedSexes" = "categories_with_repeated_sexes",
  "checkCodId" = "check_cod_id",
  "fixTALL.PESOVariable" = "fix_tall_peso_variable",
  "checkTALL.PESO" = "check_tall_peso",
  "checkSexedSpecies" = "check_sexed_species",
  "checkNoSexedSpecies" = "check_no_sexed_species",
  "checkMultipleEstratoRIM" = "check_multiple_estrato_rim",
  "checkMultipleGear" = "check_multiple_gear",
  "checkMultiplePort" = "check_multiple_port",
  "checkCoherenceEstratoRimOrigin" = "check_coherence_estrato_rim_origin",
  "checkShipsPairBottomTrawl" = "check_ships_pair_bottom_trawl",
  "checkSizeRangeByFishingGround" = "check_size_range_by_fishing_ground",
  "checkRangeInHistorical" = "check_range_in_historical",
  "checkCatchesP99" = "check_catches_p99",
  "checkStrategy" = "check_strategy",
  "multipleTypeSample" = "multiple_type_sample",
  "taxonomicSpecieConfusion" = "taxonomic_specie_confusion",
  "checkSameTripInVariousPorts" = "check_same_trip_in_various_ports",
  "checkVariableFilled" = "check_variable_filled",
  "checkMultipleShipCode" = "check_multiple_ship_code",
  "coherenceDCFMetierRimStratumOrigin" = "coherence_dcf_metier_rim_stratum_origin",
  "coherenceDCFFishingGroundRimStratumOrigin" = "coherence_dcf_fishing_ground_rim_stratum_origin",
  "allCategoriesMeasured" = "all_categories_measured",
  "checkVariableWithRimMt2PrescriptionsPost" = "check_variable_with_rim_mt2_prescriptions_post",
  "coherenceRimMt2PrescriptionsPost" = "coherence_rim_mt2_prescriptions_post",
  "checkEmptyValuesInVariables" = "check_empty_values_in_variables",
  "emptyFieldsInVariables" = "empty_fields_in_variables",
  "processLengthFileForCheckMeasures" = "process_length_file_for_check_measures",
  "prioritySpeciesNotMeasured" = "priority_species_not_measured",
  "g1SpeciesNotMeasured" = "g1_species_not_measured",
  "g2SpeciesNotMeasured" = "g2_species_not_measured",
  "checkShipNoMasterFishingGear" = "check_ship_no_master_fishing_gear",
  "checkShipDifferentFishingGear" = "check_ship_different_fishing_gear",
  "shipWhithoutCODSGPM" = "ship_without_cod_sgpm",
  "categories99NotInMt2b" = "categories_99_not_in_mt2b",
  
  # rim_post_dump_auxiliary_functions.R
  "addTypeOfError" = "add_type_of_error",
  "formatErrorsList" = "format_errors_list",
  "exportErrorsList" = "export_errors_list",
  "separateDataframeByInfluenceArea" = "separateDataframeByInfluenceArea",
  "exportListToGoogleSheet" = "export_list_to_google_sheet",
  "humanizeVariable" = "humanizeVariable",
  
  # Main script functions
  "createMonthAsCharacter" = "create_month_as_character",
  "createIdentifier" = "create_identifier",
  "importRIMFiles" = "import_rim_files",
  "copyFilesToFolder" = "copy_files_to_folder",
  "sendErrorsByEmail" = "send_errors_by_email",
  
  # R/prepareLengthsForCheckMeasures.R
  "prepareLengthsForCheckMeasures" = "prepare_lengths_for_check_measures",
  
  # R/checkNoShips_1021.R
  "checkNoShips" = "check_no_ships",
  
  # R/checkPortMismatchForSameTrip_1051.R
  "checkPortMismatchForSameTrip" = "check_port_mismatch_for_same_trip",
  
  # R/checkHalfCmMeasures_1076.R
  "checkHalfCmMeasures" = "check_half_cm_measures",
  
  # R/checkCmMeasures_1084.R
  "checkCmMeasures" = "check_cm_measures",
  
  # R/tripIsChecked_1085.R
  "tripIsChecked" = "trip_is_checked",
  
  # R/checkMoreThanTwoShips_1087.R
  "checkMoreThanTwoShips" = "check_more_than_two_ships",
  
  # R/checkNewSpeciesSampled_1088.R
  "checkNewSpeciesSampled" = "check_new_species_sampled"
)

# VARIABLE NAME MAPPINGS -------------------------------------------------------
# Maps old variable names to new snake_case names

variable_mappings <- c(
  "sampled_spe_no_mixed" = "sampled_species_no_mixed",
  "accesory_email_info" = "accessory_email_info",
  "catches_in_lengths" = "catches_in_lengths",  # already correct
  "lengths_sampled" = "lengths_sampled"  # already correct
)

# REFACTORING FUNCTIONS --------------------------------------------------------

#' Refactor a single file
#' 
#' @param file_path Path to the file to refactor
#' @param mappings Named vector of mappings (old_name = new_name)
#' @param backup Create backup before refactoring (default: TRUE)
#' @return TRUE if successful, FALSE otherwise
refactor_file <- function(file_path, mappings, backup = TRUE) {
  tryCatch({
    # Read file content
    content <- readLines(file_path, warn = FALSE)
    
    # Create backup if requested
    if (backup) {
      backup_path <- paste0(file_path, ".backup")
      writeLines(content, backup_path)
      message(paste("Created backup:", backup_path))
    }
    
    # Apply each mapping
    for (old_name in names(mappings)) {
      new_name <- mappings[[old_name]]
      
      # Pattern 1: Function definitions: old_name <- function
      pattern1 <- paste0("\\b", old_name, "\\s*<-\\s*function")
      replacement1 <- paste0(new_name, " <- function")
      content <- gsub(pattern1, replacement1, content, perl = TRUE)
      
      # Pattern 2: Function calls: old_name(
      pattern2 <- paste0("\\b", old_name, "\\s*\\(")
      replacement2 <- paste0(new_name, "(")
      content <- gsub(pattern2, replacement2, content, perl = TRUE)
      
      # Pattern 3: Variable assignments: old_name <-
      pattern3 <- paste0("\\b", old_name, "\\s*<-")
      replacement3 <- paste0(new_name, " <-")
      content <- gsub(pattern3, replacement3, content, perl = TRUE)
      
      # Pattern 4: Variable usage in expressions: old_name$, old_name[, old_name,
      pattern4 <- paste0("\\b", old_name, "\\b(?=[\\[\\$,\\s)])")
      replacement4 <- new_name
      content <- gsub(pattern4, replacement4, content, perl = TRUE)
    }
    
    # Write refactored content
    writeLines(content, file_path)
    message(paste("✓ Refactored:", file_path))
    return(TRUE)
    
  }, error = function(e) {
    message(paste("✗ ERROR refactoring", file_path, ":", e$message))
    return(FALSE)
  })
}

#' Refactor all R files in the project
#' 
#' @param pattern Regular expression pattern for files to refactor (default: all .R files)
#' @param recursive Search recursively in subdirectories (default: TRUE)
#' @param backup Create backups before refactoring (default: TRUE)
#' @return Summary data frame with results
refactor_all_files <- function(pattern = "\\.R$", recursive = TRUE, backup = TRUE) {
  # Get all R files
  r_files <- list.files(
    pattern = pattern,
    recursive = recursive,
    full.names = TRUE
  )
  
  message(paste("Found", length(r_files), "files to refactor"))
  
  # Initialize results tracking
  results <- data.frame(
    file = character(),
    functions_refactored = logical(),
    variables_refactored = logical(),
    success = logical(),
    stringsAsFactors = FALSE
  )
  
  # Refactor each file
  for (file in r_files) {
    message(paste("\n--- Processing:", file, "---"))
    
    func_result <- refactor_file(file, function_mappings, backup)
    var_result <- refactor_file(file, variable_mappings, backup = FALSE)
    
    results <- rbind(results, data.frame(
      file = file,
      functions_refactored = func_result,
      variables_refactored = var_result,
      success = func_result && var_result
    ))
  }
  
  # Summary
  message("\n=== REFACTORING SUMMARY ===")
  message(paste("Total files processed:", nrow(results)))
  message(paste("Successfully refactored:", sum(results$success)))
  message(paste("Failed:", sum(!results$success)))
  
  if (any(!results$success)) {
    message("\nFailed files:")
    print(results[!results$success, "file"])
  }
  
  return(results)
}

#' Test refactored code for syntax errors
#' 
#' @param files Vector of file paths to test (default: all .R files)
#' @return Data frame with test results
test_syntax <- function(files = NULL) {
  if (is.null(files)) {
    files <- list.files(pattern = "\\.R$", recursive = TRUE, full.names = TRUE)
  }
  
  results <- data.frame(
    file = character(),
    syntax_ok = logical(),
    error_message = character(),
    stringsAsFactors = FALSE
  )
  
  message("=== TESTING SYNTAX ===")
  
  for (file in files) {
    result <- tryCatch({
      parse(file)
      list(ok = TRUE, msg = "")
    }, error = function(e) {
      list(ok = FALSE, msg = e$message)
    })
    
    results <- rbind(results, data.frame(
      file = file,
      syntax_ok = result$ok,
      error_message = result$msg
    ))
    
    if (result$ok) {
      message(paste("✓", file))
    } else {
      message(paste("✗", file, "-", result$msg))
    }
  }
  
  message("\n=== SYNTAX TEST SUMMARY ===")
  message(paste("Total files tested:", nrow(results)))
  message(paste("Passed:", sum(results$syntax_ok)))
  message(paste("Failed:", sum(!results$syntax_ok)))
  
  return(results)
}

#' Remove all backup files
#' 
#' @param pattern Pattern to match backup files (default: .backup extension)
#' @param confirm Ask for confirmation before deletion (default: TRUE)
remove_backups <- function(pattern = "\\.backup$", confirm = TRUE) {
  backup_files <- list.files(
    pattern = pattern,
    recursive = TRUE,
    full.names = TRUE
  )
  
  if (length(backup_files) == 0) {
    message("No backup files found")
    return(invisible(NULL))
  }
  
  message(paste("Found", length(backup_files), "backup files"))
  
  if (confirm) {
    response <- readline(prompt = "Delete all backup files? (yes/no): ")
    if (tolower(response) != "yes") {
      message("Cancelled")
      return(invisible(NULL))
    }
  }
  
  file.remove(backup_files)
  message(paste("Removed", length(backup_files), "backup files"))
}

#' Restore files from backup
#' 
#' @param files Vector of file paths to restore (without .backup extension)
restore_from_backup <- function(files = NULL) {
  if (is.null(files)) {
    # Restore all files with backups
    backup_files <- list.files(
      pattern = "\\.backup$",
      recursive = TRUE,
      full.names = TRUE
    )
    files <- gsub("\\.backup$", "", backup_files)
  }
  
  restored <- 0
  for (file in files) {
    backup_file <- paste0(file, ".backup")
    if (file.exists(backup_file)) {
      file.copy(backup_file, file, overwrite = TRUE)
      message(paste("✓ Restored:", file))
      restored <- restored + 1
    } else {
      message(paste("✗ No backup found for:", file))
    }
  }
  
  message(paste("\nRestored", restored, "files"))
}

# USAGE INSTRUCTIONS -----------------------------------------------------------
# 
# 1. CREATE FULL BACKUP OF PROJECT FIRST
# 
# 2. TEST THE SCRIPT ON A SINGLE FILE:
#    refactor_file("rim_post_dump_functions.R", function_mappings)
#    test_syntax("rim_post_dump_functions.R")
# 
# 3. IF SUCCESSFUL, REFACTOR ALL FILES:
#    results <- refactor_all_files()
# 
# 4. TEST ALL REFACTORED FILES:
#    syntax_results <- test_syntax()
# 
# 5. IF ERRORS FOUND, RESTORE FROM BACKUP:
#    restore_from_backup()
# 
# 6. IF ALL OK, REMOVE BACKUPS:
#    remove_backups()
# 
# ==============================================================================

message("Refactoring helper script loaded successfully")
message("Type '?refactor_all_files' for usage instructions")
